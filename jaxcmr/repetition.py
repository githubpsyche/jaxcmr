# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/repetition.ipynb.

# %% auto 0
__all__ = ['item_to_study_positions', 'all_study_positions', 'filter_repeated_recalls', 'relabel_trial_to_firstpos',
           'make_control_dataset']

# %% ../notebooks/repetition.ipynb 2
import math
from functools import partial

import jax
import numpy as np
from jax import lax, random
from jax import numpy as jnp

from .helpers import generate_trial_mask
from .typing import Array, Int_, Integer, RecallDataset


# %% ../notebooks/repetition.ipynb 4
def item_to_study_positions(
    item: Int_,
    presentation: Integer[Array, " list_length"],
    size: int,
):
    """Returns the one-indexed study positions of an item in a 1D presentation sequence.

    Args:
        item: the item index.
        presentation: the 1D presentation sequence.
        size: max non-zero entries that could be returned
    """
    return lax.cond(
        item == 0,
        lambda: jnp.zeros(size, dtype=int),
        lambda: jnp.nonzero(presentation == item, size=size, fill_value=-1)[0] + 1,
    )


def all_study_positions(
    study_position: Int_,
    presentation: Integer[Array, " list_length"],
    size: int,
):
    """Return the one-indexed study positions associated with a given study position.

    Args:
        study_position: the study position.
        presentation: the 1D presentation sequence.
        size: max non-zero entries that could be returned
    """
    item = lax.cond(
        study_position > 0,
        lambda: presentation[study_position - 1],
        lambda: 0,
    )
    return item_to_study_positions(item, presentation, size)


# %% ../notebooks/repetition.ipynb 6
def filter_repeated_recalls(recalls: jnp.ndarray) -> jnp.ndarray:
    """Remove repeated recalls within each trial, retaining only the first occurrence.

    Args:
        recalls: 2-D array where each row is a zero-padded recall sequence.
                 Zero denotes “no recall / end of list.”

    Returns:
        A copy of `recalls` with all subsequent occurrences of an item in
        the same row set to 0.  Shape is unchanged.
    """
    n_positions = recalls.shape[1]
    matches = recalls[:, None, :] == recalls[:, :, None]
    lower_tri = jnp.tril(jnp.ones((n_positions, n_positions), bool), k=-1)
    seen_before = jnp.any(matches & lower_tri[None], axis=2)
    keep_mask = (recalls != 0) & ~seen_before
    return recalls * keep_mask


def relabel_trial_to_firstpos(
    rec_row: jnp.ndarray, pres_row: jnp.ndarray
) -> jnp.ndarray:
    """Relabel recall indices to the first occurrence of each item in the presentation.

    Args:
        rec_row: 1D array of recall indices (0 for no recall).
        pres_row: 1D array of presentation indices.
    Returns:
        A 1D array where each recall index is replaced with the first occurrence
        of that item in the presentation, or 0 if the recall was 0.
        The output has the same shape as `rec_row`.
    """
    L = pres_row.shape[0]
    idx = jnp.arange(L) + 1
    eq = pres_row[:, None] == pres_row[None, :]
    first_idx = jnp.min(jnp.where(eq, idx[None, :], L + 1), axis=1)
    return jnp.where(rec_row == 0, 0, first_idx[rec_row - 1])


@partial(jax.jit, static_argnums=(2,))
def _shuffle_and_tile_controls(
    control_recalls: jnp.ndarray,  # [n_pure_trials, n_recalls]
    mixed_presentations: jnp.ndarray,  # [n_mixed_trials, n_pres]
    n_permutations: int,  # static
    prng_key: jnp.ndarray,  # single PRNGKey
) -> tuple[jnp.ndarray, jnp.ndarray]:
    """Generate shuffled control recalls and align them with mixed-list presentations.

    Args:
        control_recalls: Pure-list recall matrices to permute (one per trial).
        mixed_presentations: Mixed-list presentation matrices to pair with.
        n_shuffles: Number of independent permutations per pure trial.
        prng_key: JAX PRNGKey used to produce all permutations.

    Returns:
        Tuple `(shuffled_recalls, tiled_presentations)` where
        `shuffled_recalls` has shape
            ``(ceil(n_mixed_trials / n_pure_trials) * n_shuffles * n_pure_trials,
              n_recalls)``
        and `tiled_presentations` has shape
            ``(n_mixed_trials * n_shuffles, n_pres)``.
        (Callers typically trim the first output to match the second.)
    """
    keys = random.split(prng_key, n_permutations)
    batched = jax.vmap(lambda k: random.permutation(k, control_recalls, axis=0))(keys)
    flat_shuffled = batched.reshape((-1, control_recalls.shape[1]))

    tiled_pres = jnp.repeat(mixed_presentations, repeats=n_permutations, axis=0)[:flat_shuffled.shape[0]]
    flat_shuffled = flat_shuffled[:tiled_pres.shape[0]]
    # assert tiled_pres.shape[0] == flat_shuffled.shape[0]
    # assert tiled_pres.shape[1] == mixed_presentations.shape[1]
    return flat_shuffled, tiled_pres


def make_control_dataset(
    data: RecallDataset,
    mixed_query: str,
    control_query: str,
    n_shuffles: int,
    remove_repeats: bool = True,
    seed: int = 0,
) -> RecallDataset:
    """Build a synthetic control dataset by shuffling pure-list recalls.

    For each subject who contributed mixed and pure trials:
      1. Select their pure-list recalls (`control_query`) and mixed-list
         presentations (`mixed_query`).
      2. Call ``_shuffle_and_tile_controls`` to create `n_shuffles`
         permuted recall blocks aligned with the mixed presentations.
      3. Optionally drop repeated recalls with ``filter_repeated_recalls``.
      4. Replicate ancillary fields (e.g. conditions, stimuli) so every new
         row has a full metadata record.

    Args:
        data: Original dataset containing at minimum the keys
              ``"subject"``, ``"recalls"``, and ``"pres_itemnos"`` plus any
              extra per-trial fields to be carried through.
        mixed_query: Boolean query string evaluated by
              ``generate_trial_mask`` to identify mixed-list trials.
        control_query: Query string identifying pure-list (control) trials.
        n_shuffles: How many shuffled control blocks to generate per subject.
        remove_repeats: If ``True``, call ``filter_repeated_recalls`` on the
              shuffled recalls.
        seed: RNG seed for reproducible shuffling.

    Returns:
        A new ``RecallDataset`` whose rows equal
        ``(#mixed_trials_with_data * n_shuffles)`` and whose fields mirror
        those in ``data`` (plus the reindexed ``subject`` column).
    """

    # 1) find which subjects actually have mixed trials
    all_subject_ids = jnp.array(data["subject"]).flatten()
    mixed_mask = generate_trial_mask(data, mixed_query)
    pure_mask = generate_trial_mask(data, control_query)
    subjects = np.unique(all_subject_ids[mixed_mask])
    prng_keys = random.split(random.PRNGKey(seed), subjects.size)

    recalls_blocks = []
    pres_blocks = []
    subject_id_blocks = []
    other_fields_acc = {
        key: [] for key in data if key not in ("recalls", "pres_itemnos", "subject")
    }

    for i, subj in enumerate(subjects):

        sel_pure = (all_subject_ids == subj) & pure_mask
        sel_mixed = (all_subject_ids == subj) & mixed_mask

        pure_recalls = jnp.array(data["recalls"][sel_pure])
        mixed_pres = jnp.array(data["pres_itemnos"][sel_mixed])
        if pure_recalls.shape[0] == 0 or mixed_pres.shape[0] == 0:
            continue

        n_pure, _ = pure_recalls.shape
        n_mixed, _ = mixed_pres.shape
        repeat_factor = math.ceil(n_mixed / n_pure)
        n_permutations = n_shuffles * repeat_factor

        new_recalls, new_pres = _shuffle_and_tile_controls(
            pure_recalls, mixed_pres, n_permutations, prng_keys[i]
        )
        # Ensure identical items share a single positional code
        new_recalls = jax.vmap(relabel_trial_to_firstpos, in_axes=(0, 0))(
            new_recalls, new_pres
        )
        if remove_repeats:
            new_recalls = filter_repeated_recalls(new_recalls)

        recalls_blocks.append(new_recalls)
        pres_blocks.append(new_pres)
        subject_id_blocks.append(jnp.full((new_recalls.shape[0], 1), subj, dtype=int))

        # carry along all other fields, repeated to match new_recalls
        for field, acc in other_fields_acc.items():
            arr = jnp.array(data[field])[sel_mixed]
            acc.append(jnp.repeat(arr, repeats=n_permutations, axis=0)[:new_recalls.shape[0]])
            assert acc[-1].shape[0] == new_recalls.shape[0]
            assert acc[-1].shape[0] == new_pres.shape[0]

    return {
        "subject": jnp.vstack(subject_id_blocks),
        "recalls": jnp.vstack(recalls_blocks),
        "pres_itemnos": jnp.vstack(pres_blocks),
        **{f: jnp.vstack(lst) for f, lst in other_fields_acc.items()},
    } # type: ignore

