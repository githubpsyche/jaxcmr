# AUTOGENERATED! DO NOT EDIT! File to edit: ../../notebooks/srac.ipynb.

# %% auto 0
__all__ = ['fixed_pres_srac', 'srac_one_trial', 'srac', 'plot_srac']

# %% ../../notebooks/srac.ipynb 2
from typing import Optional, Sequence

import jax.numpy as jnp
from jax import jit, vmap
from matplotlib import rcParams  # type: ignore
from matplotlib.axes import Axes
import matplotlib.pyplot as plt

from ..plotting import init_plot, plot_data, set_plot_labels

from ..helpers import apply_by_subject, find_max_list_length
from ..typing import Array, Bool, Float, Integer

# %% ../../notebooks/srac.ipynb 4
def fixed_pres_srac(
    recalls: Integer[Array, " trial_count recall_positions"], list_length: int
) -> Float[Array, " study_positions"]:
    """
    Returns position-specific recall accuracy, assuming uniform study lists.

    Args:
        recalls: trial by recall position array of recalled items. 1-indexed; 0 for no recall.
        list_length: the number of studied items in each trial.
    """
    return (recalls[:, :list_length] == jnp.arange(1, list_length + 1)).mean(axis=0)

# %% ../../notebooks/srac.ipynb 7
def srac_one_trial(
    presentations: jnp.ndarray,  # [L_pres]
    recalls:       jnp.ndarray   # [L_out]
) -> jnp.ndarray:               # returns [L_out] boolean
    L_out = recalls.shape[0]

    # 1. Pad (or truncate) presentations to exactly L_out, filling extras with -1
    pad_len = L_out - presentations.shape[0]
    if pad_len > 0:
        pres_ext = jnp.concatenate([
            presentations,
            jnp.full((pad_len,), -1, dtype=presentations.dtype)
        ])
    else:
        pres_ext = presentations[:L_out]

    # 2. Masks
    valid_output = pres_ext > 0         # only true where a real item was presented
    valid_recall = recalls > 0          # only true where they actually recalled

    # 3. What was recalled? clamp indices into [0, L_out-1]
    idx = jnp.clip(recalls - 1, 0, L_out - 1)
    recalled = jnp.where(valid_recall, pres_ext[idx], -1)

    # 4. Correct if recalled==expected *and* both masks hold
    return (recalled == pres_ext) & valid_output & valid_recall


def srac(
    recalls:       jnp.ndarray,  # [n_trials, L_out]
    presentations: jnp.ndarray,  # [n_trials, L_pres]
    list_length:   int = None    # unused
) -> jnp.ndarray:               # returns [L_out] float32
    n_trials, L_out = recalls.shape

    # per-trial correctness
    trial_acc = vmap(srac_one_trial, in_axes=(0, 0))(presentations, recalls)
    # per-trial validâ€‘output masks
    def trial_valid(pres):
        pad_len = L_out - pres.shape[0]
        pres_ext = jnp.concatenate([
            pres,
            jnp.full((pad_len,), -1, dtype=pres.dtype)
        ]) if pad_len>0 else pres[:L_out]
        return pres_ext > 0

    trial_valid_mask = vmap(trial_valid)(presentations)

    total_correct = trial_acc.sum(axis=0)
    total_valid   = trial_valid_mask.sum(axis=0)

    return jnp.where(total_valid > 0,
                     total_correct / total_valid,
                     0.0)


# %% ../../notebooks/srac.ipynb 9
def plot_srac(
    datasets: Sequence[dict[str, jnp.ndarray]] | dict[str, jnp.ndarray],
    trial_masks: Sequence[Bool[Array, " trial_count"]] | Bool[Array, " trial_count"],
    color_cycle: Optional[list[str]] = None,
    labels: Optional[Sequence[str]] = None,
    contrast_name: Optional[str] = None,
    axis: Optional[Axes] = None,
) -> Axes:
    """
    Plots serial recall accuracy curve for one or more datasets.

    Args:
        datasets: Datasets containing trial data to be plotted.
        trial_masks: Masks to filter trials in datasets.
        color_cycle: List of colors for plotting each dataset.
        distances: Unused, included for compatibility with other plotting functions.
        labels: Names for each dataset for legend, optional.
        contrast_name: Name of contrast for legend labeling, optional.
        axis: Existing matplotlib Axes to plot on, optional.

    Returns:
        The matplotlib Axes object containing the plot.
    """
    axis = init_plot(axis)

    if color_cycle is None:
        color_cycle = [c["color"] for c in rcParams["axes.prop_cycle"]]

    if isinstance(datasets, dict):
        datasets = [datasets]

    if isinstance(trial_masks, jnp.ndarray):
        trial_masks = [trial_masks]

    if labels is None:
        labels = ["" for _ in datasets]

    # Identify the largest list length across datasets, so we can plot consistently
    max_list_length = find_max_list_length(datasets, trial_masks)

    for data_index, data_dict in enumerate(datasets):
        # We'll apply the accurate_spc function to each subject, then stack
        subject_values = jnp.vstack(
            apply_by_subject(
                data_dict,
                trial_masks[data_index],
                jit(srac),
            )
        )

        # Plot
        color = color_cycle.pop(0)
        subject_values = subject_values[:, :max_list_length]
        xvals = jnp.arange(max_list_length) + 1
        plot_data(axis, xvals, subject_values, labels[data_index], color)

    set_plot_labels(axis, "Study Position", "Serial Recall Accuracy", contrast_name)
    return axis
