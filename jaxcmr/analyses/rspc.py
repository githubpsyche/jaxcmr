# AUTOGENERATED! DO NOT EDIT! File to edit: ../../notebooks/rspc.ipynb.

# %% auto 0
__all__ = ['trial_relative_correct', 'relative_spc', 'plot_relative_spc']

# %% ../../notebooks/rspc.ipynb 2
import jax.numpy as jnp
from jax import vmap, jit, lax

from typing import Optional, Sequence
from ..typing import Array, Float, Bool, Integer, RecallDataset
from ..repetition import all_study_positions
from ..plotting import init_plot, plot_data, set_plot_labels
from ..helpers import apply_by_subject, find_max_list_length

from matplotlib.axes import Axes
from matplotlib import rcParams  # type: ignore

# %% ../../notebooks/rspc.ipynb 4
def trial_relative_correct(
    recalls_row: Integer[Array, " recall_positions"], 
    pres_row: jnp.ndarray, size: int
) -> Bool[Array, " study_positions"]:
    """
    Per-trial correctness flags under the 'previous+1' rule.
    First recall is correct only if it is study position 1.
    """
    def step(carry, recall_i):
        # all_study_positions returns 1-indexed positions plus 0 padding
        poss = all_study_positions(recall_i, pres_row, size)
        corr = jnp.any(poss == (carry + 1))
        return recall_i, corr

    # carry starts at 0, scan over recalls_row
    _, corrs = lax.scan(step, 0, recalls_row)
    return corrs

def relative_spc(
    recalls: Integer[Array, " trial_count recall_positions"],
    presentations:Integer[Array, " trial_count study_positions"],
    list_length: Optional[int] = None,
    size: int =3,
) -> Float[Array, " study_positions"]:
    """Returns relative-order serial recall accuracy as a function of study position.

    Args:
        recalls: trial by recall position array of recalled items. 1-indexed; 0 for no recall.
        presentations: trial by study position array of presented items. 1-indexed.
        list_length: the length of the study list.
        size: maximum number of study positions an item can be presented at.
    """
    # vectorize per-trial scorer, then average over trials
    scores = vmap(lambda r, p: trial_relative_correct(r, p, size))(recalls, presentations)
    return jnp.mean(scores, axis=0)

# %% ../../notebooks/rspc.ipynb 6
def plot_relative_spc(
    datasets: Sequence[RecallDataset] | RecallDataset,
    trial_masks: Sequence[Bool[Array, " trial_count"]] | Bool[Array, " trial_count"],
    distances: Optional[Float[Array, " word_count word_count"]] = None,
    color_cycle: Optional[list[str]] = None,
    labels: Optional[Sequence[str]] = None,
    contrast_name: Optional[str] = None,
    axis: Optional[Axes] = None,
    size: int = 3,
) -> Axes:
    """Returns Axes object with plotted serial position curve for datasets and trial masks.

    Args:
        datasets: Datasets containing trial data to be plotted.
        trial_masks: Masks to filter trials in datasets.
        color_cycle: List of colors for plotting each dataset.
        distances: Unused, included for compatibility with other plotting functions.
        labels: Names for each dataset for legend, optional.
        contrast_name: Name of contrast for legend labeling, optional.
        axis: Existing matplotlib Axes to plot on, optional.
        size: Maximum number of study positions an item can be presented at.
    """
    axis = init_plot(axis)

    if color_cycle is None:
        color_cycle = [each["color"] for each in rcParams["axes.prop_cycle"]]

    if labels is None:
        labels = [""] * len(datasets)

    if isinstance(datasets, dict):
        datasets = [datasets]

    if isinstance(trial_masks, jnp.ndarray):
        trial_masks = [trial_masks]

    max_list_length = find_max_list_length(datasets, trial_masks)
    for data_index, data in enumerate(datasets):
        subject_values = jnp.vstack(
            apply_by_subject(
                data,
                trial_masks[data_index],
                jit(relative_spc, static_argnames=("size")),
                size,
            )
        )

        color = color_cycle.pop(0)
        plot_data(
            axis,
            jnp.arange(max_list_length, dtype=int) + 1,
            subject_values,
            labels[data_index],
            color,
        )

    set_plot_labels(axis, "Study Position", "Recall Rate", contrast_name)
    return axis
