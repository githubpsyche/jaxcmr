# AUTOGENERATED! DO NOT EDIT! File to edit: ../../notebooks/order_error_rate.ipynb.

# %% auto 0
__all__ = ['trial_order_error_rate', 'order_error_rate', 'plot_order_error_rate']

# %% ../../notebooks/order_error_rate.ipynb 2
from typing import Optional, Sequence

import jax.numpy as jnp
import matplotlib.pyplot as plt
from jax import jit, vmap
from matplotlib import rcParams  # type: ignore
from matplotlib.axes import Axes

from ..helpers import apply_by_subject, find_max_list_length
from ..repetition import all_study_positions
from ..plotting import init_plot, plot_data, set_plot_labels
from ..typing import Array, Bool, Float, Integer, RecallDataset


# %% ../../notebooks/order_error_rate.ipynb 5
def trial_order_error_rate(
    recalls: Integer[Array, " recall_positions"],
    presentations: Integer[Array, " study_positions"],
    size: int = 3,
) -> Bool[Array, " study_positions"]:
    """
    One Boolean per study slot:
        True  → an item from the list was reported in output slot *i*,
                but that item does *not* belong to this study position.
        False → correct, omission, intrusion, or padded study slot.
    """

    list_len = presentations.shape[0]
    study_pos_1 = jnp.arange(1, list_len + 1)          # 1-based indexes

    # 1. Token produced at each output slot i (pad with 0 if recall shorter)
    recall_tokens = jnp.where(
        study_pos_1 - 1 < recalls.shape[0],   # convert to 0-based for slicing
        recalls[:list_len],
        0,                                    # no response → treat as 0
    )

    # 2. Is that token on today’s list (and non-zero)?
    #    token k is "on the list" if 1 ≤ k ≤ list_len and presentations[k-1] ≠ 0
    token_on_list = (
        (recall_tokens > 0)
        & (recall_tokens <= list_len)
        & (presentations[recall_tokens - 1] != 0)
    )

    # 3. For each output slot, does its token actually belong here?
    #    Use all_study_positions to map token → all study slots of that item.
    expanded = vmap(all_study_positions, in_axes=(0, None, None))(
        recall_tokens, presentations, size
    )                          # shape: (list_len, size)

    correct_here = jnp.any(expanded == study_pos_1[:, None], axis=1)

    # 4. Order-error logic, ignoring padded study slots (presentations == 0)
    return token_on_list & (~correct_here) & (presentations != 0)

def order_error_rate(
    recalls: Integer[Array, " trial_count recall_positions"],
    presentations: Integer[Array, " trial_count study_positions"],
    list_length: int,
    size: int = 3,
) -> Float[Array, " study_positions"]:
    """
    Returns position-specific recall accuracy, not assuming uniform study lists.

    Args:
        recalls: trial by recall position array of recalled items. 1-indexed; 0 for no recall.
        presentations: trial by study position array of presented items. 1-indexed.
        size: the number of studied items in each trial.
    """
    return vmap(trial_order_error_rate, in_axes=(0, 0, None))(
        recalls,
        presentations,
        size,
    ).mean(axis=0)

# %% ../../notebooks/order_error_rate.ipynb 7
def plot_order_error_rate(
    datasets: Sequence[RecallDataset] | RecallDataset,
    trial_masks: Sequence[Bool[Array, " trial_count"]] | Bool[Array, " trial_count"],
    color_cycle: Optional[list[str]] = None,
    labels: Optional[Sequence[str]] = None,
    contrast_name: Optional[str] = None,
    axis: Optional[Axes] = None,
) -> Axes:
    """
    Plots serial recall accuracy curve for one or more datasets.

    Args:
        datasets: Datasets containing trial data to be plotted.
        trial_masks: Masks to filter trials in datasets.
        color_cycle: List of colors for plotting each dataset.
        distances: Unused, included for compatibility with other plotting functions.
        labels: Names for each dataset for legend, optional.
        contrast_name: Name of contrast for legend labeling, optional.
        axis: Existing matplotlib Axes to plot on, optional.

    Returns:
        The matplotlib Axes object containing the plot.
    """
    axis = init_plot(axis)

    if color_cycle is None:
        color_cycle = [c["color"] for c in rcParams["axes.prop_cycle"]]

    if isinstance(datasets, dict):
        datasets = [datasets]

    if isinstance(trial_masks, jnp.ndarray):
        trial_masks = [trial_masks]

    if labels is None:
        labels = ["" for _ in datasets]

    # Identify the largest list length across datasets, so we can plot consistently
    max_list_length = find_max_list_length(datasets, trial_masks)

    for data_index, data_dict in enumerate(datasets):
        subject_values = jnp.vstack(
            apply_by_subject(
                data_dict,
                trial_masks[data_index],
                jit(order_error_rate),
            )
        )

        # Plot
        color = color_cycle.pop(0)
        subject_values = subject_values[:, :max_list_length]
        xvals = jnp.arange(max_list_length) + 1
        plot_data(axis, xvals, subject_values, labels[data_index], color)

    set_plot_labels(axis, "Study Position", "Serial Recall Accuracy", contrast_name)
    return axis
