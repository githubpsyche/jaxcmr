[
  {
    "objectID": "context.html",
    "href": "context.html",
    "title": "Context",
    "section": "",
    "text": "TemporalContext\n\n TemporalContext (*args:Any, **kwargs:Any)\n\nTemporal context representation for memory search models.\n\n\nExported source\nimport base64\nimport io\n\nimport matplotlib.pyplot as plt\nfrom jax import numpy as jnp\nfrom simple_pytree import Pytree\n\nfrom jaxcmr.math import normalize_magnitude\nfrom jaxcmr.state_analysis import matrix_heatmap\nfrom jaxcmr.typing import Array, Float, Float_\n\n\nclass TemporalContext(Pytree):\n    \"\"\"Temporal context representation for memory search models.\"\"\"\n\n    def __init__(self, item_count: int, size: int):\n        \"\"\"Create a new temporal context model.\n\n        Args:\n            item_count: the number of items in the context model.\n            size: the size of the context representation.\n        \"\"\"\n        self.size = size\n        self.zeros = jnp.zeros(size)\n        self.state = self.zeros.at[0].set(1)\n        self.initial_state = self.zeros.at[0].set(1)\n        self.next_outlist_unit = item_count + 1\n\n    @classmethod\n    def init(cls, item_count: int) -&gt; \"TemporalContext\":\n        \"\"\"Standardized initialization for a new context model.\n\n        Args:\n            item_count: the number of items in the context model.\n        \"\"\"\n        return cls(item_count, item_count + 1)\n\n    def integrate(\n        self,\n        context_input: Float[Array, \" context_feature_units\"],\n        drift_rate: Float_,\n    ) -&gt; \"TemporalContext\":\n        \"\"\"Returns context after integrating input representation, preserving unit length.\n\n        Args:\n            context_input: the input representation to be integrated into the contextual state.\n            drift_rate: The drift rate parameter.\n        \"\"\"\n        context_input = normalize_magnitude(context_input)\n        rho = jnp.sqrt(\n            1 + jnp.square(drift_rate) * (jnp.square(self.state * context_input) - 1)\n        ) - (drift_rate * (self.state * context_input))\n        return self.replace(\n            state=normalize_magnitude((rho * self.state) + (drift_rate * context_input))\n        )\n\n    def _repr_markdown_(self):\n        \"\"\"Returns a markdown representation of the context model.\"\"\"\n        fig, ax = matrix_heatmap(self.state, figsize=(6, 0.6))\n\n        ax.set_xlabel(\"\")\n        ax.set_ylabel(\"\")\n        # ax.set_xticks([])\n        ax.set_yticks([])\n\n        # Remove colorbar safely if desired:\n        for coll in ax.collections:\n            if hasattr(coll, \"colorbar\") and coll.colorbar:\n                coll.colorbar.remove()\n\n        buf = io.BytesIO()\n        fig.savefig(buf, format=\"png\", bbox_inches=\"tight\")\n        plt.close(fig)\n\n        encoded = base64.b64encode(buf.getvalue()).decode(\"utf-8\")\n        return f'&lt;img src=\"data:image/png;base64,{encoded}\" /&gt;'\n\n\n\n\nNotes\nIn retrieved-context models, TemporalContext primarily represented as a vector of continuous values, each corresponding to a different context unit.\nThis vector is normally initialized with a start-of-list context unit and additional context units for each item in a study list. The first context unit is initialized to 1, while the remaining context units are initialized to 0.\nAn additional out-of-list context unit is sometimes included to simulate contextual drift after a memory experiment’s study phase. However, we have found that drifting context toward this out-of-list context unit does not change model performance in a meaningful way unless the drift rate is configured near 1.0. This is because in the CMR model, only relative differences between context units are important. Drifting context toward the out-of-list context unit (unless the drift extinguishes support in all other context units) does not change the relative differences between context units connected in memory within CMR to recallable items, so it does not change the model’s behavior.\nTo allow for both standardized and flexible initialization of TemporalContext, we provide an init class method for standardized initialization from just an item_count parameter, and an __init__ method for flexible initialization from both item_count and size parameters.\n\nitem_count = 10\nsize = item_count + 1\ndrift_rate = 0.3\n\ncontext = TemporalContext.init(item_count)\n\n# initial state should be 1.0 at the first element, and 0.0 elsewhere\nassert context.state[0] == 1.0\nassert jnp.all(context.state[1:] == 0.0)\n\ncontext\n\n\n\n\nThis context vector evolves as items are encoded and retrieved, integrating a new contextual input at each step. At each step \\(i\\), both models update context as\n\\[\nc_i = \\rho_i c_{i-1} + \\beta \\, c_{i}^{IN},\n\\]\nwhere \\(\\beta\\) controls integration of new input \\(c_i^{IN}\\), and \\(\\rho_i\\) normalizes the vector (i.e., enforces the unit length of the context vector):\n\\[\n\\rho_i = \\sqrt{1 + \\beta^2\\bigl[(c_{i-1} \\cdot c^{IN}_i)^2 - 1\\bigr]} \\;-\\;\\beta(c_{i-1} \\cdot c^{IN}_i).\n\\]\nThis gradual integration yields a recency-based gradient reflecting the order in which items were presented.\n\ncontext_input = jnp.zeros(size).at[-1].set(1)\nnew_context = context.integrate(context_input, drift_rate)\n\n# test: last element is now non-zero; rest are still 0.0, except for the first element\nassert new_context.state[-1] &gt; 0.0\nassert jnp.all(new_context.state[1:-1] == 0.0)\nassert new_context.state[0] &gt; 0.0\n\n# test: final state vector is unit length\nassert jnp.isclose(jnp.linalg.norm(new_context.state), 1.0, atol=1e-6)\n\nnew_context\n\n\n\n\nThe initial state of the context vector is preserved to enable drift back to the start-of-list context unit.\n\n# test: the stored `initial_state` is preserved\nprint(new_context.initial_state)\nassert jnp.all(new_context.initial_state == context.state)\n\n[1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n\n\nTemporalContext implements the typing.Context protocol. As long as a class implements this interface, it’s usable by other classes that expect a Context object.\n\nfrom jaxcmr.typing import Context\n\n\n# test: TemporalContext implements the Context interface\nassert isinstance(new_context, Context)",
    "crumbs": [
      "Context"
    ]
  }
]